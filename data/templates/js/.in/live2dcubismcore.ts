/*
 * Copyright(c) Live2D Inc. All rights reserved.
 * 
 * Use of this source code is governed by the Live2D Open Software license
 * that can be found at http://live2d.com/eula/live2d-open-software-license-agreement_en.html.
 */


/* {{{autogeneratedwarning}}} */


namespace Live2DCubismCore {
    /** Emscripten typings. */
    declare namespace _em {
        var HEAP: Int32Array;
        var IHEAP: Int32Array;
        var FHEAP: Float64Array;
  
        var HEAP8: Int8Array;
        var HEAP16: Int16Array;
        var HEAP32: Int32Array;
        var HEAPU8:  Uint8Array;
        var HEAPU16: Uint16Array;
        var HEAPU32: Uint32Array;
        var HEAPF32: Float32Array;
        var HEAPF64: Float64Array;


        function ccall(ident: string, returnType: string, argTypes: string[], args: any[]): any;
        function cwrap(ident: string, returnType: string, argTypes: string[]): any;
        function Pointer_stringify(ptr: number, length?: number): string;
        function addFunction(prt: Function, type?: string);
    }


    /**
     * Emscripten Cubism Core module.
     * 
     * This module is governed by the Live2D Proprietary Software license
     * that can be found at http://live2d.com/eula/live2d-proprietary-software-license-agreement_en.html.
     */
    ///\\\_em_module///\\\


    /** C calls. */
    class _csm {
        {{#ccalls.return}}
        public static {{{name}}}({{{args}}}): {{{returnType}}} {
            return _em.ccall("{{{entry}}}", "{{{returnType}}}", [{{{argTypes}}}], [{{{argNames}}}]);
        }
        {{/ccalls.return}}
        {{#ccalls.void}}
        public static {{{name}}}({{{args}}}) {
            _em.ccall("{{{entry}}}", null, [{{{argTypes}}}], [{{{argNames}}}]);
        }
        {{/ccalls.void}}
    }


    /** Cubism version identifier. */
    export declare type csmVersion = number;


    /** Log handler.
     * 
     * @param message Null-terminated string message to log.
     */
    export interface csmLogFunction
    {
        (message: string): void
    };


    /** Cubism version. */
    export class Version
    {
        /**
         * Queries Core version.
         * 
         * @return Core version.
         */
        public static csmGetVersion(): csmVersion
        {
            return _csm.getVersion();
        }

        private constructor(){}
    }


    /** Cubism logging. */
    export class Logging
    {
        private static logFunction: csmLogFunction;

        /**
         * Sets log handler.
         * 
         * @param handler  Handler to use.
         */
        public static csmSetLogFunction(handler: csmLogFunction): void
        {
            // Cache log handler.
            Logging.logFunction = handler;

            // Wrap function to pointer.
            let pointer = _em.addFunction(Logging.wrapLogFunction, 'vi');

            // Sets log handler.
            _csm.setLogFunction(pointer);
        }


        /**
         * Queries log handler.
         * 
         * @return Log handler.
         */
        public static csmGetLogFunction(): csmLogFunction
        {
            return Logging.logFunction;
        }


        /**
         * Wrap log function.
         * 
         * @param messagePtr number
         * 
         * @return string
         */
        private static wrapLogFunction(messagePtr: number): void
        {
            // Pointer to string.
            let messageStr = _em.Pointer_stringify(messagePtr);

            // Run log function.
            Logging.logFunction(messageStr);
        }
        private constructor(){}
    }


    /** Cubism moc. */
    export class Moc {
        /** Creates [[Moc]] from [[ArrayBuffer]].
         * 
         * @param buffer Array buffer
         * 
         * @return [[Moc]] on success; [[null]] otherwise.
         */
        public static fromArrayBuffer(buffer: ArrayBuffer): Moc {
            if (!buffer) {
                return null;
            }
            var moc = new Moc(buffer);
            return (moc._ptr)
                ? moc
                : null;
        }


        /** Releases instance. */
        public _release(): void {
            _csm.free(this._ptr);
            this._ptr = 0;
        }


        /** Native moc. */
        public _ptr : number;


        /**
         * Initializes instance.
         * 
         * @param mocBytes Moc bytes.
         */
        private constructor(mocBytes: ArrayBuffer) {
            // Allocate memory.
            var memory = _csm.mallocMoc(mocBytes.byteLength);
            if (!memory) {
                return;
            }
            // Initialize memory.
            var destination = new Uint8Array(_em.HEAPU8.buffer, memory, mocBytes.byteLength);
            destination.set(new Uint8Array(mocBytes));
            // Revive moc.
            this._ptr = _csm.reviveMocInPlace(memory, mocBytes.byteLength);
            if (!this._ptr) {
                _csm.free(memory);
            }
        }
    }


    /** Cubism model. */
    export class Model
    {
        /** Parameters. */
        public parameters: Parameters;
        /** Parts. */
        public parts: Parts;
        /** Drawables. */
        public drawables: Drawables;
        /** Canvas information. */
        public canvasinfo: CanvasInfo;

        /**
         * Creates [[Model]] from [[Moc]].
         *
         * @param moc Moc
         * 
         * @return [[Model]] on success; [[null]] otherwise.
         */
        public static fromMoc(moc: Moc): Model {
            var model = new Model(moc);
            return (model._ptr)
                ? model
                : null;
        }


        /** Updates instance. */
        public update(): void {
            _csm.updateModel(this._ptr);
        }

        /** Releases instance. */
        public release(): void {
            _csm.free(this._ptr);
            this._ptr = 0;
        }


        /** Native model. */
        public _ptr : number;


        /**
         * Initializes instance.
         * 
         * @param moc Moc
         */
        private constructor(moc: Moc)
        {
            this._ptr = _csm.mallocModelAndInitialize(moc._ptr);
            if (!this._ptr) {
                return;
            }
            this.parameters = new Parameters(this._ptr);
            this.parts = new Parts(this._ptr);
            this.drawables = new Drawables(this._ptr);
            this.canvasinfo = new CanvasInfo(this._ptr);
        }
    }

    /** Canvas information interface. */
    export class CanvasInfo
    {
        /** Width of native model canvas. */
        public CanvasWidth: number

        /** Height of native model canvas. */
        public CanvasHeight: number

        /** Coordinate origin of X axis. */
        public CanvasOriginX: number

        /** Coordinate origin of Y axis. */
        public CanvasOriginY: number

        /** Pixels per unit of native model. */
        public PixelsPerUnit: number
        
        /**
         * Initializes instance.
         * 
         * @param modelPtr Native model pointer.
         */
        public constructor(modelPtr: number)
        {
            if (!modelPtr) {
                return;
            }

            // Preserve the pointer ant heap for get data throw args.
            let _canvasSize_data = new Float32Array(2);
            let _canvasSize_nDataBytes = _canvasSize_data.length * _canvasSize_data.BYTES_PER_ELEMENT;
            let _canvasSize_dataPtr = _csm.malloc(_canvasSize_nDataBytes);
            let _canvasSize_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasSize_dataPtr, _canvasSize_nDataBytes);
            _canvasSize_dataHeap.set(new Uint8Array(_canvasSize_data.buffer));

            let _canvasOrigin_data = new Float32Array(2);
            let _canvasOrigin_nDataBytes = _canvasOrigin_data.length * _canvasOrigin_data.BYTES_PER_ELEMENT;
            let _canvasOrigin_dataPtr = _csm.malloc(_canvasOrigin_nDataBytes);
            let _canvasOrigin_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasOrigin_dataPtr, _canvasOrigin_nDataBytes);
            _canvasOrigin_dataHeap.set(new Uint8Array(_canvasOrigin_data.buffer));

            let _canvasPPU_data = new Float32Array(1);
            let _canvasPPU_nDataBytes = _canvasPPU_data.length * _canvasPPU_data.BYTES_PER_ELEMENT;
            let _canvasPPU_dataPtr = _csm.malloc(_canvasPPU_nDataBytes);
            let _canvasPPU_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasPPU_dataPtr, _canvasPPU_nDataBytes);
            _canvasPPU_dataHeap.set(new Uint8Array(_canvasPPU_data.buffer));

            // Call function and get result
            _csm.readCanvasInfo(modelPtr, _canvasSize_dataHeap.byteOffset, _canvasOrigin_dataHeap.byteOffset, _canvasPPU_dataHeap.byteOffset);

            _canvasSize_data = new Float32Array(_canvasSize_dataHeap.buffer, _canvasSize_dataHeap.byteOffset, _canvasSize_dataHeap.length);
            _canvasOrigin_data = new Float32Array(_canvasOrigin_dataHeap.buffer, _canvasOrigin_dataHeap.byteOffset, _canvasOrigin_dataHeap.length);
            _canvasPPU_data = new Float32Array(_canvasPPU_dataHeap.buffer, _canvasPPU_dataHeap.byteOffset, _canvasPPU_dataHeap.length);

            this.CanvasWidth = _canvasSize_data[0];
            this.CanvasHeight = _canvasSize_data[1];
            this.CanvasOriginX = _canvasOrigin_data[0];
            this.CanvasOriginY = _canvasOrigin_data[1];
            this.PixelsPerUnit = _canvasPPU_data[0];

            // Free heap memory
            _csm.free(_canvasSize_dataHeap.byteOffset);
            _csm.free(_canvasOrigin_dataHeap.byteOffset);
            _csm.free(_canvasPPU_dataHeap.byteOffset);
        }
    }

    {{#modelgetterclss}}

    /** {{{clsdoc}}} */
    export class {{{clsname}}} {
        {{#props}}
        /** {{{propdoc}}} */
        public {{{propname}}}: {{{proptstype}}};
        {{/props}}

        {{#funcs}}

        /** {{{funcdoc}}}. */
        public {{{funcname}}}() {
            {{{ccall}}}(this._modelPtr);
        }

        {{/funcs}}
        {{#hasfuncs}}

        /** Native model. */
        private _modelPtr: number;

        {{/hasfuncs}}

        /**
         * Initializes instance.
         *
         * @param modelPtr Native model. 
         */
        public constructor(modelPtr: number) {
            {{#hasfuncs}}
            this._modelPtr = modelPtr;


            {{/hasfuncs}}
            {{#hasarrayprop}}
            var length = 0;
            {{/hasarrayprop}}
            {{#hasarray2prop}}
            var length2: Int32Array = null;
            {{/hasarray2prop}}


            {{#scalarprops}}
            this.{{{propname}}} = {{{propget}}}(modelPtr);
            {{/scalarprops}}

            {{#stringarrayprops}}

            length = {{{propgetlength}}}(modelPtr);
            this.{{{propname}}} = new Array<string>(length);
            var _{{{propname}}} = new Uint32Array(_em.HEAPU32.buffer, {{{propget}}}(modelPtr), length{{{proplengthfactor}}});
            for(let i: number = 0; i < _{{{propname}}}.length; i++)
            {
                this.{{{propname}}}[i] = _em.Pointer_stringify(_{{{propname}}}[i]);
            }
            {{/stringarrayprops}}
            {{#scalararrayprops}}

            length = {{{propgetlength}}}(modelPtr);
            this.{{{propname}}} = new {{{proptstype}}}({{{propemheapbuffer}}}, {{{propget}}}(modelPtr), length{{{proplengthfactor}}});
            {{/scalararrayprops}}
            {{#scalararray2props}}

            length = {{{propgetlength}}}(modelPtr);
            length2 = new Int32Array(_em.HEAP32.buffer, {{{propgetlength2}}}(modelPtr), length{{{proplengthfactor}}});
            this.{{{propname}}} = new {{{proptstype}}}(length);
            var _{{{propname}}} = new Uint32Array(_em.HEAPU32.buffer, {{{propget}}}(modelPtr), length{{{proplengthfactor}}});
            for(let i: number = 0; i < _{{{propname}}}.length; i++)
            {
                this.{{{propname}}}[i] = new {{{proparray1tstype}}}({{{propemheapbuffer}}}, _{{{propname}}}[i], length2[i]{{{proplength2factor}}});
            }
            {{/scalararray2props}}
        }
    }

    {{/modelgetterclss}}

    /** Utility functions. */
    export class Utils {
        {{#flags}}
        {{#entries}}
        /**
         * Checks whether flag is set in bitfield.
         * 
         * @param bitfield Bitfield to query against.
         * 
         * @return [[true]] if bit set; [[false]] otherwise
        */
        public static has{{{Flagname}}}Bit(bitfield: number): boolean {
            return (bitfield & (1 << {{{flagindex}}})) == (1 << {{{flagindex}}});
        }
        {{/entries}}
        {{/flags}}
    }
}
